<p align="center"><a href="https://cloudinary.com" target="_blank">			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 96.77" width="500" height="97" fill="blue">
				<path
					d="M160.53 30.41a17.14 17.14 0 0 1 13.56 6.7.69.69 0 0 0 1 .11l5.71-4.55a.71.71 0 0 0 .11-1 26 26 0 0 0-20.61-10.13c-14.91 0-27 12.85-27 28.65s12.13 28.65 27 28.65a25.85 25.85 0 0 0 20.6-10.12.69.69 0 0 0-.12-1l-5.7-4.5a.71.71 0 0 0-1 .11A17.26 17.26 0 0 1 160.53 70c-10.19 0-18.16-8.7-18.16-19.79s7.97-19.8 18.16-19.8ZM188.27 19.91h7.16a.71.71 0 0 1 .71.71V77.4a.7.7 0 0 1-.7.7h-7.16a.71.71 0 0 1-.71-.71V20.62a.7.7 0 0 1 .7-.71ZM220.54 39.55c-9.49 0-19.09 6.72-19.09 19.57 0 11.29 8.21 19.81 19.09 19.81s19.17-8.52 19.17-19.81-8.24-19.57-19.17-19.57Zm10.53 19.57c0 6.52-4.53 11.44-10.53 11.44s-10.44-4.92-10.44-11.44 4.49-11.2 10.44-11.2 10.53 4.81 10.53 11.2ZM278.3 40.37h-7.16a.7.7 0 0 0-.71.7v19c0 7.42-5.12 10.05-9.51 10.05-3.88 0-7.79-2.93-7.79-9.48V41.07a.7.7 0 0 0-.71-.7h-7.16a.7.7 0 0 0-.7.7v20.5c0 11.25 5.09 17.44 14.34 17.44 3.36 0 8.8-1.93 10.84-6.19l.69.14v4.44a.71.71 0 0 0 .71.71h7.16a.71.71 0 0 0 .71-.71V41.07a.7.7 0 0 0-.71-.7ZM322.27 19.91h-7.17a.7.7 0 0 0-.7.71V46l-.44-.7c-2.18-3.51-6.87-5.78-11.95-5.78-8.76 0-17.62 6.75-17.62 19.65 0 11.25 7.61 19.73 17.69 19.73 3.84 0 9.25-1.54 11.88-5.86l.44-.72v5.08a.7.7 0 0 0 .7.71h7.17a.7.7 0 0 0 .7-.71V20.62a.7.7 0 0 0-.7-.71Zm-8 39.21a11 11 0 0 1-10.75 11.36c-5.86 0-10.45-5-10.45-11.36s4.59-11.2 10.45-11.2a11 11 0 0 1 10.72 11.2ZM333 40.37h7.16a.7.7 0 0 1 .7.7V77.4a.7.7 0 0 1-.7.7H333a.71.71 0 0 1-.71-.71V41.07a.71.71 0 0 1 .71-.7ZM336.61 21.06a5.57 5.57 0 0 0-5.69 5.57 5.64 5.64 0 0 0 5.69 5.58 5.54 5.54 0 0 0 5.61-5.58 5.48 5.48 0 0 0-5.61-5.57ZM370.35 39.55c-3.14 0-8.72 1.69-10.85 6.19l-.69-.14v-4.53a.7.7 0 0 0-.71-.7h-7.16a.7.7 0 0 0-.7.7V77.4a.7.7 0 0 0 .7.71h7.16a.71.71 0 0 0 .71-.71v-19c0-7.36 5.12-10 9.51-10 3.88 0 7.79 2.91 7.79 9.4v19.6a.71.71 0 0 0 .71.71H384a.71.71 0 0 0 .71-.71V56.91c-.02-11.19-5.12-17.36-14.36-17.36ZM427.48 40.37h-7.16a.7.7 0 0 0-.71.7v5l-.43-.7c-2.19-3.51-6.88-5.78-12-5.78-8.75 0-17.62 6.75-17.62 19.65 0 11.25 7.61 19.73 17.7 19.73 3.83 0 9.24-1.54 11.88-5.86l.43-.72v5.01a.71.71 0 0 0 .71.71h7.16a.7.7 0 0 0 .7-.71V41.07a.7.7 0 0 0-.66-.7Zm-8 18.75a11 11 0 0 1-10.78 11.36c-5.86 0-10.44-5-10.44-11.36s4.58-11.2 10.44-11.2a11 11 0 0 1 10.76 11.2ZM460.15 40.5a13.66 13.66 0 0 0-5.14-1c-4.76 0-8.22 2.85-10 8.25l-.64-.09v-6.59a.7.7 0 0 0-.71-.7h-7.16a.7.7 0 0 0-.71.7V77.4a.71.71 0 0 0 .71.71h7.24a.7.7 0 0 0 .7-.71V65c0-14.8 5.91-17 9.44-17a11 11 0 0 1 4.33.9.72.72 0 0 0 .61 0 .7.7 0 0 0 .36-.48l1.42-7.11a.71.71 0 0 0-.45-.81ZM499.88 40.68a.69.69 0 0 0-.59-.31h-7.71a.72.72 0 0 0-.66.45L481.59 65l-9.42-24.18a.72.72 0 0 0-.66-.45h-7.86a.69.69 0 0 0-.58.31.7.7 0 0 0-.07.66l14 34.38-7.73 20.09a.71.71 0 0 0 .66 1h7.5a.69.69 0 0 0 .65-.45l21.86-55a.69.69 0 0 0-.06-.68ZM97.91 28.11A40.38 40.38 0 0 0 59.73 0 39.62 39.62 0 0 0 24.6 20.87a29.88 29.88 0 0 0-7.21 56.56l.75.34h.05v-8.5a22.29 22.29 0 0 1 9.29-41.16l2.1-.22.92-1.89A32.15 32.15 0 0 1 59.73 7.57a32.7 32.7 0 0 1 31.55 25l.72 2.86h3a18.53 18.53 0 0 1 18.15 18.46c0 7.05-4.07 12.82-11 15.74v8.06l.5-.16c11.14-3.65 18.06-12.71 18.06-23.64a26.19 26.19 0 0 0-22.8-25.78Z"></path>
				<path
					d="m45.07 76.79 1.66 1.66a.33.33 0 0 1-.23.56H33.4a6 6 0 0 1-6-6V47.57a.33.33 0 0 0-.33-.33h-2.8a.33.33 0 0 1-.24-.56l11.12-11.12a.33.33 0 0 1 .47 0l11.11 11.12a.33.33 0 0 1-.23.56h-2.84a.34.34 0 0 0-.34.33v25a6 6 0 0 0 1.75 4.22ZM69.64 76.79l1.67 1.66a.33.33 0 0 1-.24.56H58a6 6 0 0 1-6-6V54a.34.34 0 0 0-.33-.34h-2.83a.33.33 0 0 1-.23-.56L59.72 42a.33.33 0 0 1 .47 0l11.12 11.08a.33.33 0 0 1-.24.56h-2.84a.34.34 0 0 0-.33.34v18.59a6 6 0 0 0 1.74 4.22ZM94.22 76.79l1.66 1.66a.33.33 0 0 1-.23.56H82.54a6 6 0 0 1-6-6V60.38a.33.33 0 0 0-.33-.33h-2.8a.33.33 0 0 1-.23-.57L84.3 48.37a.32.32 0 0 1 .46 0l11.12 11.11a.33.33 0 0 1-.23.57H92.8a.33.33 0 0 0-.33.33v12.19a6 6 0 0 0 1.75 4.22Z"></path>
			</svg>
</a></p>

<h1 align="center">
 Speedy Web Apps with Cloudinary Image Optimization
</h1>

Cloudinary is a Software-as-a-Service (SaaS) solution for managing all your web or mobile application’s media assets in
the cloud. Cloudinary offers an end-to-end solution for all your image and video needs, including the upload, storage,
administration, transformation and optimized delivery.

## Introduction

Images make up a large portion of the overall web traffic. On Instagram alone, over 95 million photos are shared daily. Delivery images in a fast and efficient way can improve the overall performance of a web application. In this article, we will cover some techniques that can be used with Cloudinary to make this seamless. We will demonstrate how one can use Cloudinary to speed up their web apps. At the end of this article we will have a web application that loads faster retains more users and provides a better user experience.

## PHPSandbox and Github

The final project can be viewed on [PHPSandbox]( https://phpsandbox.io/e/x/4pg3m?layout=EditorPreview&defaultPath=%2F&theme=dark&showExplorer=no&openedFiles= ) and the entire source code is available on my [Github](https://github.com/victorokech/cloudinary-speed) repository.

## Prerequisites

Using Cloudinary in your Laravel projects is pretty straightforward. However, for you to be able to easily follow along,
you need to have a good command of your terminal, Git and entry knowledge of PHP specifically with the Laravel
framework.

## Getting Started

This assumes you already have composer installed. Laravel uses Composer to manage its dependencies. So, before we can
start ensure you have Composer installed on your machine.

1. Install [Composer](https://getcomposer.org/) and [PHP](https://www.php.net/manual/en/install.windows.tools.php) on
   your development or production machine.
2. Install Laravel
    1. Via Composer:

       `composer create-project --prefer-dist laravel/laravel cloudinary-speed`
    2. Via Laravel Installer

       `composer global require laravel/installer`

       `laravel new cloudinary-speed`
3. In step 2 above we have created a project folder called `cloudinary-speed`. Change the directory to this
   project folder and run the local development server by typing the following commands:

   `cd cloudinary-speed`

   `php artisan serve`

The Laravel Project is now up and running.

![Laravel Running](https://res.cloudinary.com/dgrpkngjn/image/upload/v1655976836/assets/laravel-running.png)

## Setting up Cloudinary’s Laravel SDK

Using Cloudinary allows you to optimize the performance of your Laravel backend by allowing you to upload, process, and
deliver your media files. Cloudinary's servers automatically perform optimizations and scales to handle high loads and
bursts of traffic with a global content delivery network (CDN) feature. This is great for our media platform.

To implement a content-aware crop for our media files with Cloudinary:

1. Sign up for a free Cloudinary account then navigate to the Console page and take note of your Cloud name, API Key and
   API Secret.


![Cloudinary Dashboard](https://res.cloudinary.com/dgrpkngjn/image/upload/v1655976836/assets/cloudinary_dashboard.png)


3. Install [Cloudinary’s Laravel SDK](https://github.com/cloudinary-labs/cloudinary-laravel#installation):

   `composer require cloudinary-labs/cloudinary-laravel`

**Note**: Please ensure you follow all the steps in the #Installation section. Publish the configuration file and add
the Cloudinary credentials you noted in Step 1 to the .env file.

## Uploading Image Files

To demonstrate image optimization we will need a UI (User Interface), we will be using the Laravel package Livewire to build this and the image file upload functionality.

1. Install Livewire Package by running the following command in your Laravel project:

   `composer require livewire/livewire`


2. Include Livewire scripts and styles on every page that will be using Livewire. In our case `welcome.blade.php`:
```html
...
    @livewireStyles
</head>
<body>
    ...
    
    @livewireScripts
</body>
</html>
```
3. We will then create a Livewire Component to handle our image uploads:

   `php artisan make:livewire ImageUpload`

This will create two files, one in `app/Http/Livewire/ImageUpload` and the other one
in `resources/views/livewire/image-upload.blade.php`

Now you can use this component anywhere in your Laravel project using the following snippet:

`<livewire:image-upload/>`

or

`@livewire(‘image-upload’)`

3. Open `resources/views/welcome.blade.php` and add the following code within the `<body></body>` tags as shown below:

```html
<body class="antialiased">
  <div>
    @livewire('image-upload')
  </div>
</body>
```

This basically includes the Livewire component we created earlier into our `welcome.blade.php`.

**Note:** Please ensure you go through the [Livewire documentation](https://laravel-livewire.com/docs/2.x/quickstart), to learn how to install and set it up.

3. Open the file `resources/views/livewire/image-upload.blade.php` and populate it with the following code:

```html
<form class="mb-5" wire:submit.prevent="upload">
	<div class="form-group row mt-5 mb-3">
		<div class="input-group">
			<input type="file" class="form-control @error('media') is-invalid @enderror"
			       placeholder="Choose file..." id="media-file" type="file" wire:model="media">
			@error('media')
			<div class="invalid-feedback">{{ $message }}</div>
			@enderror
		</div>
		<small class="text-muted text-center mt-2" wire:loading wire:target="media">
			{{ __('Uploading') }}&hellip;
		</small>
	</div>
	<div class="text-center">
		<button type="submit" class="btn btn-sm btn-primary w-25">
			<i class="fas fa-check mr-1"></i> {{ __('Optimize') }}
		</button>
	</div>
</form>

<!-- Original Image -->
<div class="card-body">
	<img class="card-img-top" src="{{ $media }}" alt="Original Image" width="400" height="600">
	<h5 class="card-title mt-4 fw-bold">
		Original Image
	</h5>
</div>

<!-- Optimized Image -->
<div class="card-body">
	<img class="card-img-top" src="{{ $optimizedImage }}" alt="Optimized Image" width="400" height="600">
	<h5 class="card-title mt-4 fw-bold">
		Optimized Image
	</h5>
</div>
```

This is our Livewire Component view, this basically will display the form and on successful optimization
through Cloudinary will display the optimized image file.

The first part of the code above is a form with an input of type file and a submit button.

The second part will take the response from Cloudinary and display the non-optimized image and the optimized image from Cloudinary.

**Note:** you will see the implementation in code shortly.

## Understanding Image Optimization with Cloudinary
Hold your horses, before we start coding away, we need to understand what image optimization is and specifically how to do it well with Cloudinary.

### The Right Image Format
There are several image formats with PNGs and JPEGs being some of the most popular formats. Image formats have their strengths and weaknesses like PNGs allow you to display transparent images which JPEGs cannot.

As a rule of thumb we use:

1. Vector Images - for simple shapes like logos, icons, texts etc
2. Raster Images  - for complex scenes, these are basically the image formats that users upload to platforms like Instagram. They are complex photos taken from device cameras.

We also have newer formats like WebP, JPEG-XR, with better encoding but are only supported in newer browsers. This makes it challenging choosing which format to send to the browser. You can take advantage of Cloudinary’s `fetch (f_)` transformation to choose and specify the format you want.

For instance, you want the PNG format, you can specify the format after the underscore `f_png` as follows:

`https://res.cloudinary.com/demo/image/fetch/c_scale,h_400/f_png/https://en.wikipedia.org/wiki/File:Benedict_Cumberbatch_2008.jpg`

In this transformation the original image is a JPG but thanks to Cloudinary and specifying `f_png` we will get back an optimized PNG image.

PNG is not the best in all scenarios, and we might need to take a more dynamic approach which will allow Cloudinary to automatically determine the best format suited for a particular browser based on its capabilities. RIP Internet Explorer. To do this we use `f_auto`:

`https://res.cloudinary.com/demo/image/fetch/c_scale,h_400/f_auto/https://en.wikipedia.org/wiki/File:Benedict_Cumberbatch_2008.jpg`

For more information on these transformations, check out the official [Cloudinary guide](https://cloudinary.com/documentation/image_transformations#automatic_format_selection).

### Lazy Loading
Lazy Loading Images is a set of techniques in web and application development that defer the loading of images on a page to a later point in time - when those images are actually needed, instead of loading them up front. These techniques help in improving performance, better utilization of the device’s resources, and reducing associated costs.

When Lazy Loading images it is important to use the most efficient rendering method. By default, [Cloudinary](https://cloudinary.com/blog/progressive_jpegs_and_green_martians) uses progressive rendering which is one of the two ways in which to optimize images and make them display faster even on sluggish connections.

We can specify this in our transformations using the transformation `fl_progressive`.

### Smart Quality Optimization
There is no standard quality and encoding setting that works for all images. Luckily Cloudinary provides a smart solution to handling image compression without compromising on visual quality. This is done using the transformation `q_auto`:

`https://res.cloudinary.com/demo/image/upload/w_600/q_auto/beach_huts.jpg`

Cloudinary automates the file size versus visual quality trade-off decision, on-the-fly, by using perceptual metrics and heuristics that tune the encoding settings and select the appropriate image quality based on the specific image content and format.

### Serve Scaled Images
The last pillar of core web vitals when it comes to image optimization is sizing.

Web application design requires display of images in varied sizes. Delivering full size images and relying on browser-side resizing using CSS or HTML width and height attributes forces the user to render unnecessary bytes and suffer the cons of a slow loading application which is heavy on user resources like bandwidth, CPU and more.

Like magic, Cloudinary swoops in to save us by providing resizing transformations. The sizing (scaling/cropping) is performed on their servers, and always delivering an image to the browser at the requested size.


## Implementation in Code
Enough theory lets code. We will use all the above techniques in our code. 

Open the file `app/Http/Livewire/ImageUpload.php`. Here, we are going to add a method that will upload an image to
   Cloudinary applying the necessary transformations for optimization, compression and resizing. Add the following code in this file.
1. First we use Livewires `WithFileUploads` to help us with file uploads, then create two variables `$media`
       and `$optimizedImage` which is an array that will contain the image URLs we get back from Cloudinary.
    ```php
   use Livewire\WithFileUploads;
   
   public $media;
   public $optimizedImage;
    ```
2. Secondly, we will create the upload function which will upload the image file to [Cloudinary](https://cloudinary.com) and
       apply specific transformation which will compress, resize and optimize our images for a speedy web application.
   ```php
   public function upload() {
    ...
   }  
   ```
3. Lets populate our method in step 2 above:
    ```php
    public function upload() {
      // First we validate the input from the user
      $data = $this->validate([
        'media' => [
          'required',
          'image',
          'mimes:jpeg,jpg,png',
          ],
      ]);
      
      /*We will now set the transformations required to optimize the images based on recommended optimization solutions*/
      $cloud_name = env('CLOUDINARY_CLOUD_NAME', 'dgrpkngjn');
      $folder = 'cloudinary-speed';
      $media = $data['media'];
      $width = '700';
      $height = '800';
      $quality = 'auto';
      $fetch = 'auto';
      $crop = 'scale';
      
      $optimal = cloudinary()->upload($media->getRealPath(), [
        'folder'         => $folder,
        'transformation' => [
          'width'   => $width,
          'height'  => $height,
          'quality' => $quality,
          'fetch'   => $fetch,
          'crop'    => $crop
          ]
      ])->getSecurePath();
   
      $non-optimal = cloudinary()->upload($media->getRealPath(),[
        'folder_name' => $folder   
      ])->getSecurePath();
                    
      // Optimized image fetching
      /* Fetching an optimized image applying the transformations we specified which will compress, resize and optimize our images for a speedy web application */
      $slice = Str::afterLast($image, '/');
      $optimized = "https://res.cloudinary.com/{$cloud_name}/image/upload/w_{$width},h_{$height},c_{$crop}/{$folder}/{$slice}";
        
      $this->optimizedImage = $optimized;
   
      // Non optimized version for comparison
      $this->media = $non_optimal;
    } 
    ```
   The code above will upload an image to Cloudinary and return an optimized image URL. Cloudinary automatically optimizes the image size with no compromise in quality. This is done by setting the `auto` value for the `quality` and `fetch` attributes. We have also specified the image width and height which will instruct Cloudinary to resize and scale the image based on these parameters.
    
    **Note:** There is a non optimized image for comparison.

If you successfully implemented the code above, you should be able to see the following when you navigate to your project on the browser:

![Speedy Web Apps with Cloudinary](https://res.cloudinary.com/dgrpkngjn/image/upload/v1655977607/assets/cloudinary_speed_vdsole.png)

As you can see the Cloudinary Optimized Image loads faster. Don't take my word for it, you can test it out on this [demo](https://4pg3m.ciroue.com/). Just upload a super large image, less than 10 MB of course. 

**Note:** Cloudinary is super powerful for the management of your media assets in your project that will not only optimize your assets for visual quality but also cost savings in terms of performance, storage, AI powered transformations as well.

# Optimization with Cloudinary
Cloudinary is your A to Z media management solution - upload, storage, administration, manipulation, optimization and delivery.

[Get started](https://cloudinary.com/signup) with Cloudinary in your Laravel projects for FREE!
